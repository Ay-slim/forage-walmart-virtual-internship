### Custom heap implementation

- Uses an array and its indices to implement a max heap (priority queue) which allows any parent node to have 2^x children (where x is a variable of the heap class called spawn_exponent in this implementation)
- The [calculate_child_indices](https://github.com/Ay-slim/power-of-2-max-heap/blob/2c5ecdef44f45ea24cb8481f8ee5dc7d6158c02a/python_implementation/utils/calculate_child_indices.py#L1) and [calculate_parent_index](https://github.com/Ay-slim/power-of-2-max-heap/blob/872a72dccc97e5bae0d0a3cf597096cbd322bb51/python_implementation/utils/calculate_parent_index.py#L1) util functions use the array indices to find any node's parent or children
- *Insertion*: The insertion property of the heap class uses the [heapify_up](https://github.com/Ay-slim/power-of-2-max-heap/blob/89f18c5c7443b548731aa1d5e15e99140abf6525/python_implementation/utils/heapify_up.py) util to add an element at the end of the heap then 'bubble' it up the heap if its parent or any other ancestor nodes have a lower value
- *pop_max*: To pop off the heap's maximum value and keep it balanced, the [fill_node_holes](https://github.com/Ay-slim/power-of-2-max-heap/blob/e88b0ca6f7c7a172aa2557380fbdc5b79affc1b5/python_implementation/utils/fill_node_holes.py) util function goes down the heap picking the maximum value amongst the children nodes to replace a parent node. A "longest ancestry" path is first generated(which is the path from root to "youngest child" element that requires no rebalancing of the heap),and this is used as a guide while going down the heap. When the node being evaluated isn't on this path, a horizontal switch is done, and the [heapify_down](https://github.com/Ay-slim/power-of-2-max-heap/blob/d14f501c6eede1efff252f39f3f5b81f495bacfa/python_implementation/utils/heapify_down.py) util function is immediately called to rebalance the heap.

P.S: The model solution solved the pop_max method elegantly(java_implementation). Rather than find an "ancestry path", they simply pick the youngest child element, set it in the max position, then run the equivalent of the heapify_down (named swap_down) method on the heap, removing the need for the left-right switch while still keeping the heap complete.


- Reference: [Advanced Data Structures Walmart task on Forage](https://www.theforage.com/virtual-internships/oX6f9BbCL9kJDJzfg?ref=jwa5Z4pAvjDRT4GnD)
- Starting with a Python implementation. Will eventually rewrite in Java.
